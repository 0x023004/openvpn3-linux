#!/usr/bin/python2
#  OpenVPN 3 Linux client -- Next generation OpenVPN client
#
#  Copyright (C) 2017 - 2018  OpenVPN Inc. <sales@openvpn.net>
#  Copyright (C) 2017 - 2018  David Sommerseth <davids@openvpn.net>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Affero General Public License as
#  published by the Free Software Foundation, version 3 of the
#  License.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Affero General Public License for more details.
#
#  You should have received a copy of the GNU Affero General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

##
# @file  openvpn2
#
# @brief This is an attempt to make a simplistic front-end user interface
#        for the OpenVPN 3 D-Bus based VPN client which feels more like the
#        well known and classic OpenVPN 2.x client.
#
#        Only client side options are supported, and only the features which
#        have been made available in the OpenVPN 3 Core library.

from enum import Enum
from getpass import getpass
import argparse
import dbus
import os
import shlex
import sys
import time


# Detect if pyOpenSSL is available or not.
# This module is used to parse PKCS#12 files only
# and if not present when needed, it will complain
# later on.
HAVE_OPENSSL = True
try:
    import OpenSSL.crypto as crypto
except ImportError:
    HAVE_OPENSSL = False

# Add the traceback module if we're in debugging mode.
# This will allow dumping of tracebacks when exceptions happens
if 'OPENVPN3_DEBUG' in os.environ:
    import traceback


##
#  StatusMajor constants
#  Generated by utils/gen-python-constants
class StatusMajor(Enum):
    UNSET = 0
    CFG_ERROR = 1
    CONNECTION = 2
    SESSION = 3
    PKCS11 = 4
    PROCESS = 5


##
#  StatusMinor constants
#  Generated by utils/gen-python-constants
class StatusMinor(Enum):
    UNSET = 0
    CFG_ERROR = 1
    CFG_OK = 2
    CFG_INLINE_MISSING = 3
    CFG_REQUIRE_USER = 4
    CONN_INIT = 5
    CONN_CONNECTING = 6
    CONN_CONNECTED = 7
    CONN_DISCONNECTING = 8
    CONN_DISCONNECTED = 9
    CONN_FAILED = 10
    CONN_AUTH_FAILED = 11
    CONN_RECONNECTING = 12
    CONN_PAUSING = 13
    CONN_PAUSED = 14
    CONN_RESUMING = 15
    CONN_DONE = 16
    SESS_NEW = 17
    SESS_BACKEND_COMPLETED = 18
    SESS_REMOVED = 19
    SESS_AUTH_USERPASS = 20
    SESS_AUTH_CHALLENGE = 21
    SESS_AUTH_URL = 22
    PKCS11_SIGN = 23
    PKCS11_ENCRYPT = 24
    PKCS11_DECRYPT = 25
    PKCS11_VERIFY = 26
    PROC_STARTED = 27
    PROC_STOPPED = 28
    PROC_KILLED = 29


##
#  Translates a D-Bus object's status property into
#  Python constants.
#
#  @param status  The full contents of the session objects status property
#
#  @returns A tuple of (StatusMajor, StatusMinor, status_message)
#
def ParseStatus(status):
    return (StatusMajor(status['major']), StatusMinor(status['minor']),
            status['status_message'])


##
#  Configuration parser for OpenVPN command line options and configuration
#  files.  This implementation only adds the client related options the
#  OpenVPN 3 Core library supports.  Some options are ignored, as it is
#  possible to establish a connection even though the core library does not
#  use them.
#
#  This parser is also trying to behave as close as possible
#  to the classic OpenVPN 2.x
#
#
class OpenVPNconfigParser():
    def __init__(self, args, descr):
        self.__args = args[1:]
        self.__parser = argparse.ArgumentParser(prog=args[0],
                                                description=descr)
        self.__init_arguments()
        self.__opts = vars(self.__parser.parse_args(self.__args))


    def GenerateConfig(self):
        cfg = []
        for opt_key, opt_val in self.__opts.iteritems():
            if 'daemon' == opt_key:
                # Don't put 'daemon' into the generated config,
                # that is not a useful option for the OpenVPN 3 backend and we
                # handle this in the front-end instead.
                continue;
            key = opt_key.replace('_', '-')
            if isinstance(opt_val, bool):
                if opt_val is True:
                    cfg.append(key)
            elif isinstance(opt_val, list):
                for v in opt_val:
                    cfg.append('%s %s' %(key, v))
            elif opt_val is not None:
                if key in ('ca', 'cert', 'extra-certs', 'http-proxy-user-pass',
                           'key', 'tls-auth', 'tls-crypt'):
                    # Embedded files should not be prefixed by the key value
                    cfg.append(opt_val)
                else:
                    cfg.append('%s %s' % (key, opt_val))
        return '\n'.join(cfg)


    def GetConfigName(self):
        try:
            return getattr(self.__parser, 'config_name')
        except AttributeError:
            return None


    def GetDaemon(self):
        return self.__opts['daemon']


    def GetPersistTun(self):
        try:
            return self.__opts['persist_tun']
        except AttributeError:
            return False


    ##
    #  Checks if we have at least the pure minimum of options and arguments
    #  to establish a connection.
    #
    #  If not all required options are present, it will throw an execption
    #
    def SanityCheck(self):
        missing = []
        required = ('client', 'remote', 'ca')
        for req in required:
            if self.__opts.has_key(req):
                val = self.__opts[req]
                if val is None or val is False:
                    missing.append('--%s' % req)
                elif isinstance(val, list):
                    if 'remote' == req and len(val) < 1:
                        missing.append('--%s' % req)
                elif isinstance(val, str) and len(val) < 1:
                    missing.append('--%s' % req)

        if len(missing) > 0:
            raise Exception('The following options are missing to establish '
                            +' a connection: %s' % ', '.join(missing))


    def __init_arguments(self):
        self.__parser.add_argument('--auth', metavar='ALG',
                                   action='store',
                                   nargs=1,
                                   help='Authenticate packets with HMAC using'
                                   +' message digest algorithm alg'
                                   +' (default=SHA1)')

        # FIXME: Need to tackle loading creds from file, which is optional
        self.__parser.add_argument('--auth-user-pass',
                                   action='store_true',
                                   help='Authenticate with server using '
                                   + 'username/password')

        self.__parser.add_argument('--ca', metavar='FILE',
                                   action=OpenVPNconfigParser.EmbedFile,
                                   help='Certificate authority file in '
                                   + '.pem format containing root certificate')

        self.__parser.add_argument('--cert', metavar='FILE',
                                   action=OpenVPNconfigParser.EmbedFile,
                                   dest='cert', embed_tag='cert',
                                   help='Certificate authority file in .pem '
                                   + 'format by a Certificate Authority in '
                                   + '--ca file')

        self.__parser.add_argument('--cipher', metavar='ALG',
                                   action='store',
                                   help='Encrypt packets with cipher '
                                   +' algorithm alg'
                                   +' (default=BF-CBC)')

        self.__parser.add_argument('--client',
                                   action='store_true',
                                   help='Configures client configuration mode'
                                   + ' (mandatory)')

        self.__parser.add_argument('--comp-lzo', metavar='[MODE]',
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   help='Use LZO compression '
                                   + '(Deprecated, use --compress instead)')

        self.__parser.add_argument('--compress', metavar='[ALG]',
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   help='Compress using algorithm ALG')

        self.__parser.add_argument('--config', metavar='FILE',
                                   action=OpenVPNconfigParser.ReadConfigFile,
                                   help='Read configuration options from file')

        self.__parser.add_argument('--daemon',
                                   action='store_true',
                                   help='Run the VPN tunnel in the background')

        self.__parser.add_argument('--dev', metavar='DEV-NAME',
                                   action='store',
                                   nargs=1,
                                   help='tun/tap device to use for VPN tunnel')

        self.__parser.add_argument('--dev-type', metavar='DEV-TYPE',
                                   action='store',
                                   nargs=1,
                                   help='Which device type are we using? tun '
                                   + 'or tap. Not needed if --dev starts with'
                                   + 'tun or tap')

        self.__parser.add_argument('--dhcp-option', metavar='OPTION [...]',
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   min_args=1,
                                   help='Set DHCP options which can be picked'
                                   + 'up by the OS configuring DNS, etc')

        self.__parser.add_argument('--extra-certs', metavar='FILE',
                                   action=OpenVPNconfigParser.EmbedFile,
                                   dest='extra-certs', embed_tag='extra-certs',
                                   help='Specify a file containing one or '
                                   + 'more PEM certs (concatenated together) '
                                   + 'that complete the local certificate '
                                   + 'chain.')

        self.__parser.add_argument('--float',
                                   action='store_true',
                                   help='Allow remote to change its IP '
                                   + 'address/port')

        self.__parser.add_argument('--hand-window', metavar='SEC',
                                   action='store',
                                   nargs=1,
                                   help='Handshake window. The TLS-based key '
                                   + 'exchange must finalize within SEC '
                                   + 'seconds handshake initiation by any '
                                   + 'peer. (Default 60 seconds)')

        self.__parser.add_argument('--http-proxy',
                                   metavar='SRV PORT [auth] [auth-method]',
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   min_args=2,
                                   help='Connect to a remote host via an HTTP'
                                   + 'proxy at address SRV and port PORT. See'
                                   + ' manual for auth details')

        self.__parser.add_argument('--http-proxy-user-pass', metavar='FILE',
                                   action=OpenVPNconfigParser.EmbedFile,
                                   help='Fetch HTTP proxy credentials from '
                                   + 'FILE')

        self.__parser.add_argument('--ifconfig',
                                   metavar='LOCAL NETMASK',
                                   action='store',
                                   nargs=2,
                                   help='Configure TUN/TAP device with LOCAL '
                                   + 'for local IPv4 address with netmask '
                                   + 'NETMASK')

        self.__parser.add_argument('--ifconfig-ipv6',
                                   metavar='LOCAL [REMOTE_ENDP]',
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   min_args=1,
                                   help='Configure TUN/TAP device with LOCAL '
                                   + 'for local IPv6 address and REMOTE_ENDP '
                                   + 'as the remote end-point')

        self.__parser.add_argument('--inactive', metavar='SECS [BYTES]',
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   min_args=1,
                                   help='Exit after n seconds of activity on '
                                   + 'TUN/TAP device. If BYTES is added, '
                                   + 'if bytes on the device is less than BYTES'
                                   + ' the tunnel will also exit')

        self.__parser.add_argument('--keepalive', metavar='P_SECS R_SECS',
                                   action='store',
                                   nargs=2,
                                   help='Ping remote every P_SECS second and '
                                   + 'restart tunnel if no response within '
                                   + 'R_SECS seconds')

        self.__parser.add_argument('--key', metavar='FILE',
                                   action=OpenVPNconfigParser.EmbedFile,
                                   help='Local private key in .pem format')

        self.__parser.add_argument('--key-direction', metavar='DIR',
                                   action='store',
                                   choices=['0', '1'],
                                   nargs=1,
                                   help='Set key direction for static keys.'
                                   + ' Valid values: 0, 1')

        self.__parser.add_argument('--local', metavar='HOST',
                                   action='store',
                                   nargs=1,
                                   help='Local host name or IP address to '
                                   'to bind against on local side')

        self.__parser.add_argument('--lport', metavar='PORT',
                                   action='store',
                                   nargs=1,
                                   help='TCP/UDP port number for local bind '
                                   + '(default 1194)')

        self.__parser.add_argument('--mode', metavar='MODE',
                                   action='store',
                                   choices=['client'],
                                   nargs=1,
                                   help='Operational mode. Only "client" is'
                                   + 'accepted')

        self.__parser.add_argument('--mssfix', metavar='BYTES',
                                   action='store',
                                   nargs=1,
                                   help='Set upper bound on TCP MSS '
                                   + '(Default tun-mtu size)')

        client_server_ch = ['client', 'server']
        self.__parser.add_argument('--ns-cert-type', metavar='TYPE',
                                   action='store',
                                   choices=client_server_ch,
                                   nargs=1,
                                   help='(DEPRECATED) Require that peer '
                                   + 'certificate is signed with an explicit '
                                   + 'nsCertType designation.  '
                                   + 'Migrate to --remote-cert-tls ASAP. '
                                   + 'Valid values: '
                                   + ', '.join(client_server_ch))

        self.__parser.add_argument('--persist-tun',
                                   action='store_true',
                                   help='Keep tun/tap device open across '
                                   + 'connection restarts')

        self.__parser.add_argument('--ping', metavar='SECS',
                                   action='store',
                                   nargs=1,
                                   help='Ping remote once per SECS seconds')

        self.__parser.add_argument('--ping-restart', metavar='SECS',
                                   action='store',
                                   nargs=1,
                                   help='Restart if n seconds pass without '
                                   + 'reception of remote ping')

        self.__parser.add_argument('--pkcs12', metavar='FILE',
                                   action=OpenVPNconfigParser.PKCS12Parser,
                                   help='PKCS#12 file containing local private '
                                   + 'key, local certificate and optionally '
                                   + 'the root CA certificate')

        self.__parser.add_argument('--port', metavar='PORT',
                                   action='store',
                                   nargs=1,
                                   help='TCP/UDP port number for both local '
                                   + 'and remote.')

        self.__parser.add_argument('--proto', metavar='PROTO',
                                   action='store',
                                   choices=['udp', 'tcp'],
                                   nargs=1,
                                   help='Use protocol PROTO for communicating '
                                   +'with peer. Valid values: udp, tcp')

        self.__parser.add_argument('--push-peer-info',
                                   action='store_true',
                                   help='Push client info to server')

        redirflags = ['autolocal', 'def1', 'bypass-dhcp'
                      'bypass-dns', 'block-local',
                      'ipv4', '!ipv4', 'ipv6', '!ipv6']
        self.__parser.add_argument('--redirect-gateway', metavar='[FLAGS]',
                                   choices=redirflags,
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   help='Automatically execute routing '
                                   + 'commands to redirect all outgoing IP '
                                   + 'traffic through the VPN.  Valid flags: '
                                   + ', '.join(redirflags))

        self.__parser.add_argument('--redirect-private', metavar='[FLAGS]',
                                   choices=redirflags,
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   help='Like --redirect-gateway, but omit '
                                   + 'actually changing default gateway.'
                                   + 'Valid flags: ' + ', '.join(redirflags))

        self.__parser.add_argument('--remote', metavar='HOST [PORT [PROTO]]',
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   min_args=1,
                                   help='Remote host or IP. PORT number and '
                                   'PROTO are optional. May be provided '
                                   'multiple times.')

        self.__parser.add_argument('--remote-cert-eku', metavar='OID',
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   min_args=1,
                                   help='Require the peer certificate to be '
                                   + 'signed with explicit extended key usage. '
                                   + 'OID can be an object identifier or '
                                   + 'OpenSSL string representation.')

        self.__parser.add_argument('--remote-cert-ku', metavar='ID',
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   min_args=1,
                                   help='Require that the peer certificate was '
                                   + 'signed with explicit key usage (ID). '
                                   + 'More than one ID can be provided. Must '
                                   + 'be hexadecimal notation of integers')

        self.__parser.add_argument('--remote-cert-tls', metavar='TYPE',
                                   action='store',
                                   choices=client_server_ch,
                                   nargs=1,
                                   help='Require that peer certificate is '
                                   + 'signed with explicit key usage and '
                                   + 'extended key usage based RFC3280 rules. '
                                   + 'Valid values: '
                                   + ', '.join(client_server_ch))

        self.__parser.add_argument('--remote-random',
                                   action='store_true',
                                   help='If multiple --remote options '
                                   + 'specified, choose one randomly')

        self.__parser.add_argument('--reneg-sec', metavar='SECS',
                                   action='store',
                                   nargs=1,
                                   help='Renegotiate data channel key after '
                                   + 'SECS seconds. (Default 3600)')

        self.__parser.add_argument('--route',
                                   metavar='NETWORK [NETMASK [GATEWAY '
                                   + '[METRIC]]]',
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   min_args=1,
                                   help='Add route to routing table after '
                                   + 'connection is established.  Multiple '
                                   + 'routes can be specified. Default '
                                   + 'NETMASK: 255.255.255.255.  Default '
                                   + 'GATEWAY is taken from --route-gateway '
                                   + 'or --ifconfig')

        self.__parser.add_argument('--route-gateway', metavar='[GW|dhcp]',
                                   action='store',
                                   nargs=1,
                                   help='Specify a default gateway for use '
                                   + 'with --route. See man page for dhcp mode')

        self.__parser.add_argument('--route-ipv6',
                                   metavar='NETWORK/PREFIX [GATEWAY [METRIC]]',
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   min_args=1,
                                   help='Add IPv6 route to routing table after '
                                   + 'connection is established.  Multiple '
                                   + 'routes can be specified. Default GATEWAY '
                                   + 'is taken from \'remote\' in '
                                   + '--ifconfig-ipv6')

        self.__parser.add_argument('--route-metric', metavar='METRIC',
                                   action='store',
                                   nargs=1,
                                   help='Specify a default metric for use with '
                                   + '--route')

        self.__parser.add_argument('--route-nopull',
                                   action='store_true',
                                   help='Do not configure routes pushed by '
                                   + 'remote server')

        self.__parser.add_argument('--server-poll-timeout', metavar='SECS',
                                   action='store',
                                   nargs=1,
                                   help='How long to wait for a response from '
                                   + 'a remote server during connection setup '
                                   + ' (Default 120 seconds)')

        self.__parser.add_argument('--setenv', metavar='NAME [VALUE]',
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   min_args=1,
                                   help='Set a custom environmental variable '
                                   + 'to pass to script.')

        self.__parser.add_argument('--static-challenge', metavar='MSG ECHO',
                                   action=OpenVPNconfigParser.OpenVPNvarArgs,
                                   min_args=2,
                                   help='Enable static challenge/response '
                                   + 'protocol using challenge text MSG, with '
                                   + 'ECHO indicating echo flag (0|1)')

        self.__parser.add_argument('--tcp-queue-limit', metavar='NUM',
                                   action='store',
                                   nargs=1,
                                   help='Maximum number of queued TCP output '
                                   + 'packets')

        self.__parser.add_argument('--tls-auth', metavar='FILE [DIR]',
                                   action=OpenVPNconfigParser.EmbedTLSauth,
                                   help='Add additional HMAC auth on TLS '
                                   + 'control channel. FILE must be a shared '
                                   + 'secret. DIR is optional and defines '
                                   + 'which sub-keys in FILE to use for '
                                   + 'HMAC signing and verification')

        cert_profiles = ['legacy','preferred','suiteb']
        self.__parser.add_argument('--tls-cert-profile', metavar='PROFILE',
                                   action='store',
                                   choices=cert_profiles,
                                   help='Sets certificate profile which '
                                   + 'defines acceptable crypto algorithms. '
                                   + 'Valid profiles: '
                                   + ', '.join(cert_profiles))

        self.__parser.add_argument('--tls-client',
                                   action='store_true',
                                   help='Enable TLS and assume client role '
                                   + 'during TLS handshake. Implicitly added '
                                   + 'when using --client')

        self.__parser.add_argument('--tls-crypt', metavar='FILE',
                                   action=OpenVPNconfigParser.EmbedFile,
                                   help='Encrypts the TLS control channel '
                                   + 'with a shared secret key (FILE).  This'
                                   + 'CANNOT be combined with --tls-auth')

        self.__parser.add_argument('--tls-timeout', metavar='SECS',
                                   action='store',
                                   help='Packet retransmit timeout on TLS '
                                   + 'control channel if no ACK from remote '
                                   + 'within n seconds (Default 2 seconds')

        topologies = ['subnet', 'net30']
        self.__parser.add_argument('--topology', metavar='TYPE',
                                   action='store',
                                   choices=topologies,
                                   nargs=1,
                                   help='Set tunnel topology type. '
                                   + 'Default is net30. Recommended: subnet.'
                                   + 'Valid topologies: '
                                   + ', '.join(topologies))

        self.__parser.add_argument('--tran-window', metavar='SECS',
                                   action='store',
                                   nargs=1,
                                   help='Transition window -- old data channel '
                                   + 'key can live this many seconds after new'
                                   + 'after new key renegotiation begins '
                                   + '(Default 3600 secs)')

        self.__parser.add_argument('--tun-mtu', metavar='SIZE',
                                   action='store',
                                   nargs=1,
                                   help='Set TUN/TAP device MTU to SIZE and '
                                   + 'derive TCP/UDP from it (default is 1500)')

        self.__parser.add_argument('--verb',
                                   metavar= 'LEVEL',
                                   action='store',
                                   nargs=1,
                                   help='Set log verbosity level.  Log levels '
                                   +'are NOT compatible with OpenVPN 2 --verb ')


        descr = 'The following options are ignored and not processed.  These ' \
        + 'options are not implemented in the OpenVPN 3 Core library ' \
        + 'and will not break existing configurations.'
        ignored = self.__parser.add_argument_group('Ignored options', descr)

        ignored.add_argument('--chroot',
                             metavar='DIR',
                             action=OpenVPNconfigParser.IgnoreArg,
                             nargs=1,
                             help='Chroot to this directory after '
                             + 'initialization. Not applicable with OpenVPN 3, '
                             + 'which uses a different execution model.')

        ignored.add_argument('--explicit-exit-notify',
                             metavar='[ATTEMPTS]',
                             action=OpenVPNconfigParser.IgnoreArg,
                             nargs='+',
                             help='On exit/restart, send exit signal to remote '
                             + 'end. Automatically configured with OpenVPN 3')

        ignored.add_argument('--group',
                             metavar='GROUP',
                             action=OpenVPNconfigParser.IgnoreArg,
                             nargs=1,
                             help='Run OpenVPN with GROUP group credentials. '
                             + 'Not needed with OpenVPN 3 which uses a '
                             + 'different privilege separation approach')

        ignored.add_argument('--nice',
                             metavar='LEVEL',
                             action=OpenVPNconfigParser.IgnoreArg,
                             nargs=1,
                             help='Change process priority. Not supported in '
                             + 'OpenVPN 3')

        ignored.add_argument('--nobind',
                             action=OpenVPNconfigParser.IgnoreArg,
                             nargs=0,
                             help='Do not bind to local address and port. '
                             + 'This is default behaviour in OpenVPN 3')

        ignored.add_argument('--persist-key',
                             action=OpenVPNconfigParser.IgnoreArg,
                             nargs=0,
                             help='Do not re-read key files across connection '
                             + 'restarts. Not needed. OpenVPN 3 keeps keys '
                             + 'as embedded file elements in the configuration')

        ignored.add_argument('--rcvbuf',
                             metavar='SIZE',
                             action=OpenVPNconfigParser.IgnoreArg,
                             nargs=1,
                             help='Set the TCP/UDP receive buffer size. Not '
                             + 'supported in OpenVPN 3')

        ignored.add_argument('--sndbuf',
                             metavar='SIZE',
                             action=OpenVPNconfigParser.IgnoreArg,
                             nargs=1,
                             help='Set the TCP/UDP send buffer size. Not '
                             + 'supported in OpenVPN 3')

        ignored.add_argument('--socket-flags',
                             metavar='FLAGS',
                             action=OpenVPNconfigParser.IgnoreArg,
                             nargs='+',
                             help='Applies flags to the transport socket. Not '
                             + 'supported in OpenVPN 3')

        ignored.add_argument('--user',
                             metavar='USER',
                             action=OpenVPNconfigParser.IgnoreArg,
                             nargs=1,
                             help='Run OpenVPN with USER user credentials. '
                             + 'Not needed with OpenVPN 3 which uses a '
                             + 'different privilege separation approach')

        ignored.add_argument('--verify-x509-name',
                             metavar='SUBJECT [FLAGS]',
                             action=OpenVPNconfigParser.IgnoreArg,
                             nargs='+',
                             help='Accept connections only with a host with '
                             + 'X509 subject.  Not yet implemented in '
                             + 'OpenVPN 3')
        # ENDFNC: __init_arguments()


    ##
    #  Special argparser extension which is capable of parsing
    #  a configuration file.  And it handles recursive inclusion, so
    #  configuration files may contain the 'config' to include other
    #  settings to the main configuration
    #
    class ReadConfigFile(argparse.Action):
        def __init__(self, option_strings, dest, nargs=None, **kwargs):
            super(OpenVPNconfigParser.ReadConfigFile, self).__init__(option_strings, dest, **kwargs)

        def __call__(self, parser, namespace, values, option_string=None):
            #
            # Parse the configuration file
            #
            fp = open(values, 'r')

            # Remove new line markers on each line and only consider lines which
            # has not been commented out
            cfg = []
            embedded = {}
            tmp = None
            embedded_key = None
            for opt in [l.strip() for l in fp.readlines() if 0 < len(l.split('#')[0])]:
                if len(opt) == 0:
                    # Skip empty lines
                    continue

                # Check if we have a start-tag for embedded blob
                # An embedded blob is always the option name enclosed in
                # '<' and '>'.  The end of the embedded blob is closed with
                # '</option-name>'.
                if embedded_key is None and opt[0] == '<':
                    # Embedded blob found.  When embedded_key is _NOT_ None, we
                    # are inside an embedded blob tag.
                    tmp = [opt,]
                    embedded_key = opt[1:len(opt)-1]
                elif embedded_key is not None and '</' + embedded_key + '>' != opt:
                    # When inside an embedded blob, save the contents
                    tmp.append(opt)
                elif embedded_key is not None and '</' + embedded_key + '>' == opt:
                    # On closure of the embedded blob, save it separately.  This
                    # should not be parsed by the argument parser further.
                    tmp.append(opt)
                    embedded[embedded_key] = '\n'.join(tmp)
                    embedded_key = None
                else:
                    # When outside an embedded blob, copy the option and its
                    # arguments to be parsed further
                    cfg.append('--' + opt)

            # Parse the collected arguments further and merge them with the
            # already parsed argument
            args = vars(parser.parse_args(shlex.split('\n'.join(cfg),
                                                      posix=False)))
            for (k,v) in args.iteritems():
                setattr(namespace, k, v)

            # Merge in embedded blobs, without further parsing
            for (k,v) in embedded.iteritems():
                setattr(namespace, k, v)

            # Remove the option triggering this call from the namespace.
            # This option (self.dest) is not needed as the provided config file
            # has already been parsed and embedded.
            #
            # There is one exception though, the very first --config will be
            # preserverd, and stored as config_name.
            if 'config' == self.dest:
                try:
                    cfgname = getattr(parser, 'config_name')
                except AttributeError:
                    setattr(parser, 'config_name', values)
            delattr(namespace, self.dest)
        # ENDFNC: ReadConfigFile::__call__()
    # ENDCLASS: ReadConfigFile

    ##
    #  Some OpenVPN options may take one or more arguments.  This tackles
    #  these odd cases
    class OpenVPNvarArgs(argparse.Action):
            def __init__(self, option_strings, dest, nargs=None, **kwargs):
                try:
                    self.__min_args = kwargs.pop('min_args')
                except KeyError:
                    self.__min_Args = 0
                super(OpenVPNconfigParser.OpenVPNvarArgs, self).__init__(option_strings, dest, '*', **kwargs)

            def __call__(self, parser, namespace, values, option_string=None):
                # Always presume that these types of options can be
                # enslisted multiple times.  So we will always extend
                # a list where self.dest matches an existing key

                dst = getattr(namespace, self.dest)
                if dst is None:
                    dst = []

                min_args = 0
                try:
                    min_args = self.__min_args
                except AttributeError:
                    pass

                if isinstance(values, list):
                    if len(values) < min_args:
                        err = 'The --%s requires at least %i arguments' % (self.dest, min_args)
                        raise argparse.ArgumentError(self, err)

                    dst.append(' '.join(values))
                else:
                    dst.append(values)

                setattr(namespace, self.dest, dst)


    ##
    #  Options related to keying material needs to be embedded in an
    #  OpenVPN 3 configuration profile.  This argparser extension
    #  will generate an embedded file option on-the-fly
    #
    class EmbedFile(argparse.Action):
        def __init__(self, option_strings, dest, nargs=None, **kwargs):
            # Add a new argument to the add_argument() method
            # The embed_tag variable is the tag name used when
            # generating the tag.  If not set, use the same as the
            # destination name
            if 'embed_tag' in kwargs:
                self.__tag = kwargs.pop('embed_tag')
            else:
                self.__tag = dest
            super(OpenVPNconfigParser.EmbedFile, self).__init__(option_strings, dest, nargs, **kwargs)

        def __call__(self, parser, namespace, values, option_string=None):
            """Loads the given file and generates an embedded option of it"""

            try:
                fp = open(values, 'r')
                ret = '<%s>\n' % self.__tag
                ret += '\n'.join([l.strip() for l in fp.readlines()])
                ret += '\n</%s>' % self.__tag
                fp.close()
                setattr(namespace, self.dest, ret)
            except IOError, e:
                err = str(e.strerror) + " '" + values + "'"
                raise argparse.ArgumentError(self, err)

    # ENDCLASS: EmbedFile


    class EmbedTLSauth(EmbedFile):
        def __init__(self, option_strings, dest, nargs=None, **kwargs):
            # Add a new argument to the add_argument() method
            # The embed_tag variable is the tag name used when
            # generating the tag.  If not set, use the same as the
            # destination name
            if 'embed_tag' in kwargs:
                self.__tag = kwargs.pop('embed_tag')
            else:
                self.__tag = 'tls-auth'
            super(OpenVPNconfigParser.EmbedFile, self).__init__(option_strings, dest, '+', **kwargs)

        def __call__(self, parser, namespace, values, option_string=None):
            """Loads the tls-auth file, generates an embedded option of it
            and considers if there is a key-direction argument as well
            """

            # If values is a list, we have filename and key-direction
            filename = values
            if isinstance(values, list):
                setattr(namespace, 'key-direction', values[1])
                filename = values[0]

            fp = open(filename, 'r')
            ret = '<%s>\n' % self.__tag
            ret += '\n'.join([l.strip() for l in fp.readlines()])
            ret += '\n</%s>' % self.__tag
            fp.close()
            setattr(namespace, self.dest, ret)


    ##
    #  Special file parser for PKCS12 files.  Will extract keys and
    #  certificates and embed them to the configuration as embedded files
    #
    class PKCS12Parser(argparse.Action):
        def __init__(self, option_strings, dest, nargs=None, **kwargs):
            super(OpenVPNconfigParser.PKCS12Parser, self).__init__(option_strings, dest, **kwargs)

        def __call__(self, parser, namespace, values, option_string=None):
            # Bail out with an error if we don't have pyOpenSSL installed
            if not HAVE_OPENSSL:
                raise Exception('pyOpenSSL library is not installed.  '
                                + 'Cannot parse PKCS#12 files.')

            # Read the PKCS12 file into a memory buffer (p12bin)
            # and decode it (p12)
            with open(values, 'rb') as f:
                p12bin = f.read()
            p12 = None

            # First try without password
            try:
                p12 = crypto.load_pkcs12(p12bin)
            except crypto.Error, e:
                if 'PKCS12_parse' == e.message[0][1] and \
                   'mac verify failure' == e.message[0][2]:
                    # Password is needed.  Query the user for it
                    p12 = crypto.load_pkcs12(p12bin,
                                             getpass('PKCS12 passphrase: '))

            # Extract CA, certificate and private key
            d = '<key>\n%s</key>' % (crypto.dump_privatekey(crypto.FILETYPE_PEM,
                                                          p12.get_privatekey()))
            setattr(namespace, 'key', d)

            d = '<cert>\n%s</cert>' % (crypto.dump_certificate(crypto.FILETYPE_PEM,
                                                          p12.get_certificate()))
            setattr(namespace, 'cert', d)

            cacerts = []
            for c in p12.get_ca_certificates():
                cacerts.append(crypto.dump_certificate(crypto.FILETYPE_PEM,
                                                       c))
            if 0 < len(cacerts):
                d = '<ca>\n%s</ca>' % (''.join(cacerts),)
                setattr(namespace, 'ca', d)

            # We don't want to save this option, it is not useful as
            # we've already split up the PKCS#12 file into appropriate
            # sub-elements
            delattr(namespace, 'pkcs12')
        # ENDFNC: PKCS12Parser::__call__()
    # ENDCLASS: PKCS12Parser


    ##
    #  Options using this argparse.Action variant will just be ignored
    #  and never passed on further for the following parsing
    class IgnoreArg(argparse.Action):
        def __init__(self, option_strings, dest, nargs=None, **kwargs):
            super(OpenVPNconfigParser.IgnoreArg, self).__init__(option_strings, dest, nargs, **kwargs)

        def __call__(self, parser, namespace, values, options_string):
            # Ensure this option/argument is not preserved
            delattr(namespace, self.dest)
# ENDCLASS: OpenVPNconfigParser



def import_config(bus, opts):
    # Retrieve the main configuration manager object
    manager_object = bus.get_object('net.openvpn.v3.configuration',
                                    '/net/openvpn/v3/configuration')

    # Retireve access to the proper interface in the object
    config_interface = dbus.Interface(manager_object,
                                      dbus_interface='net.openvpn.v3.configuration')

    # Only preserver the imported configuration if we're debugging
    single_use = True
    if 'OPENVPN3_DEBUG' in os.environ:
        single_use = False

    cfgname = opts.GetConfigName();
    path = config_interface.Import(cfgname and cfgname or '(command line)', #name
                                   opts.GenerateConfig(),     # config_str
                                   single_use,                # single_use
                                   False)                     # persistent

    if opts.GetPersistTun() is True:
        # If --persist-tun was provided, set the persist_tun property
        # in the imported configuration
        cfg_object = bus.get_object('net.openvpn.v3.configuration', path)
        cfg_interf = dbus.Interface(cfg_object, 'org.freedesktop.DBus.Properties')
        cfg_interf.Set('net.openvpn.v3.configuration', 'persist_tun', True)

    if not single_use:
        print('Configuration path: %s' % path)

    return path


def print_statistics(session_properties):
    statistics = session_properties.Get('net.openvpn.v3.sessions',
                                        'statistics')
    if len(statistics) > 0:
        print('Connection statistics:')
        for (key, val) in statistics.iteritems():
            print('    %25s: %i' % (key, val))


def start_tunnel(bus, cfgpath, daemon):
    # Retrieve the main session manager object
    manager_object = bus.get_object('net.openvpn.v3.sessions',
                                    '/net/openvpn/v3/sessions')

    # Retireve access to the proper interface in the object
    sessmgr_interface = dbus.Interface(manager_object,
                                       dbus_interface='net.openvpn.v3.sessions')

    # Prepare the tunnel (type casting string to D-Bus objet path variable)
    session_path = sessmgr_interface.NewTunnel(cfgpath)

    # Get access to the session object
    session_object = bus.get_object('net.openvpn.v3.sessions', session_path)

    # Get the proper interface access, both to manage the session
    # and to retrieve properties from the session object
    session_interface = dbus.Interface(session_object,
                                       dbus_interface='net.openvpn.v3.sessions')
    session_properties = dbus.Interface(session_object,
                                        dbus_interface='org.freedesktop.DBus.Properties')

    #
    #  Starting the tunnel ...
    #
    done = False
    status = None
    exit_code = 0
    while done is False:
        try:
            time.sleep(1) # FIXME: Catch a signal when backend is ready

            # Check if the backend needs something more from us ...
            session_interface.Ready()   # This throws an exception if not ready
            session_interface.Connect() # Start the connection

            # Simple poll routine to catch the situation of the tunnel
            # The 'status' property in a session object contains the last status
            # update sent by the VPN backend
            connected = False
            connecting_prompt = False
            while done is False and connected is False:
                time.sleep(1)  # Don't race too quickly forward

                status = session_properties.Get('net.openvpn.v3.sessions',
                                                'status')
                (status_maj, status_min, status_msg) = ParseStatus(status)

                if StatusMajor.CONNECTION == status_maj:
                    if StatusMinor.CONN_CONNECTING == status_min:
                        if connecting_prompt is False:
                            sys.stdout.write('Connecting ...')
                            sys.stdout.flush()
                            connecting_prompt = True
                        else:
                            sys.stdout.write('.')
                            sys.stdout.flush()

                    elif StatusMinor.CONN_CONNECTED == status_min:
                        print('\nConnected')
                        connected = True
                        if daemon is False:
                            try:
                                # FIXME: Dump log entries and wait for CTRL-C or other signals
                                #   + listen for other signals from the session,
                                #   in case being disconnected/paused/resumed from a different user
                                input('Press enter to disconnect')
                                done = True
                            except:
                                print('\nDisconnecting ...')
                                done = True

                    elif status_min in (StatusMinor.CONN_DISCONNECTED,
                                        StatusMinor.CONN_DONE):
                        s  = len(status_msg) > 0 \
                            and status_msg or '(No information)'
                        print('\nConnection got disconnected: ' + s)
                        done = True

                    elif StatusMinor.CONN_AUTH_FAILED == status_min:  # StatusMinor:CONN_AUTH_FAILED
                        print(' Authentication failed')
                        done = True
                        exit_code = 3

                    else:  # Not handled status codes
                        print('{Status: major=%s, minor=%s, message="%s"}' %
                              (status_maj.name, status_min.name, status_msg))
                        exit_code = 7

                if connected is False and done is False:
                    # Check if everything is okay.  If authentication
                    # failed, or a dynamic challenge is sent, then an
                    # exception is thrown again
                    session_interface.Ready()


            # If we're not running in the background
            if daemon is False:
                if connected is True:
                    # If connected, retrieve and dump the last connection
                    # statistics
                    print_statistics(session_properties)
                # ... and complete the disconnect, which shuts down the backend
                session_interface.Disconnect()
                print('Disconnected')

            else:  # If we are running in the background ...
                if connected:
                    # ... and we're connected, print important details
                    print('Running connection in the background.  To manage '
                          + 'this connection, use')
                    print('the openvpn3 command line tool with the session '
                          +'path below:')
                    print('>>> Session path: ' + session_path)
            done = True

        except dbus.exceptions.DBusException, excep:
            # Do we need provide user credentials?
            if str(excep).find(' Missing user credentials') > 0:
                print('Credentials needed')

                # User credentials comes in tuples of (type, group).
                # Type should always be 1 - that is the type for user credentials.
                for (qtype, qgroup) in session_interface.UserInputQueueGetTypeGroup():
                    # Skip non-user credentials requests
                    if 1 != qtype:
                        continue

                    # Print the request to the console and send the response back
                    # to the VPN backend
                    for qid in session_interface.UserInputQueueCheck(qtype, qgroup):
                        req = session_interface.UserInputQueueFetch(qtype, qgroup, qid)

                        # Field 5 in the request defines if input should be masked or not
                        # Field 4 contains the string to be presented to the user
                        try:
                            if False == req[5]:
                                response = raw_input(req[4] + ': ')
                            else:
                                response = getpass(req[4] + ': ')
                        except KeyboardInterrupt:
                            # Shutdown the backend client
                            print("\nAborting")
                            session_interface.Disconnect()
                            return 8
                        session_interface.UserInputProvide(qtype, qgroup, qid,
                                                           response)

            elif str(excep).find(' Backend VPN process have died'):
                if 3 == exit_code:  # Authentication failed, this is expected
                    break
                if 'OPENVPN3_DEBUG' in os.environ:
                    print ('\nstart_tunnel() [1] traceback:\n')
                    print (traceback.format_exc())
                raise Exception('VPN backend process stopped unexpectedly. '
                                +'Session has closed.')
            else:
                if 'OPENVPN3_DEBUG' in os.environ:
                    print ('\nstart_tunnel() [2] traceback:\n')
                    print (traceback.format_exc())
                # Other exceptions are re-thrown
                raise excep
        except KeyboardInterrupt:
            if connected is True:
                # If connected, retrieve and dump the last connection
                # statistics
                print_statistics(session_properties)
            print("\nClosing session")
            session_interface.Disconnect()

    return exit_code



def openvpn2_main(args):
    if len(args) < 2:
        raise Exception('No options provided.  See "%s --help" for details.' %
                        args[0])

    # Simulate the classic OpenVPN 2.x behaviour where it can take a
    # single file name as the argument, which is the config file name
    if len(args) == 2 and '--' != args[1][0:2]:
        args.insert(1, '--config')

    # Parse provided provided on the command line
    opts = OpenVPNconfigParser(args, 'OpenVPN 2.x wrapper for OpenVPN 3')
    opts.SanityCheck()
    if 'OPENVPN3_DEBUG' in os.environ and 'DUMP_PARSE' == os.environ['OPENVPN3_DEBUG']:
        print (opts.GenerateConfig())
        sys.exit(0)

    # Get a connection to the D-Bus' system bus
    bus = dbus.SystemBus()

    # Import the configuration, which is stored in the configuration manager
    cfgpath = import_config(bus, opts)

    # Start the tunnel, which his managed by the session manager
    ret = start_tunnel(bus, cfgpath, opts.GetDaemon())

    return ret



if __name__ == '__main__':
    ret = 9
    try:
        ret = openvpn2_main(sys.argv)
    except KeyboardInterrupt:
        print("")
        ret = 8
    except Exception, e:
        print ('\n** ERROR ** %s' % str(e.message))
        ret = 2

        if 'OPENVPN3_DEBUG' in os.environ:
            print ('\nmain traceback:')
            print (traceback.format_exc())

    sys.exit(ret)
